Testing approaches for embedded systems:
One of the most popular approaches is model-based testing. A model is generated either with forward or backward engineering
	- With forward engineering, the model is designed after the requirement analysis phase.
	- With backward engineering, the model is retrieved by performing reverse engineering on the system's implementation

Models can then be used for test-case generation; often FSMs are used for this step with coverage criteria such as all-transition coverage. Other approaches include MATLAB Simulink models, Model Definition Language, and UML sequence diagrams.

Model-based testing can be generalized into the X-in-the-loop paradigm, which consists of Model-in-the-Loop (MiL), Software-in-the-Loop (SiL), Processor-in-the-Loop (PiL), Hardware-in-the-loop (HiL), and System-in-the-Loop (SYSiL).



Formally, the search problem for branch coverage can be formulated as follows:

\begin{problem}(Branch coverage):
    Let $ B = \{b_1,...,b_k\} $ be the set of branches in a program; find a test suite $ T = \{t_1,...,t_n \} $ of n test cases that covers all feasible branches, minimizing the fitness function:
    \begin{equation}
        min f_B (T) = |M| - |M_T| + \sum_{b \in B} d(b, T)
    \end{equation}
    where $|M|$ is the total number of methods, $|M_T|$ is the number of executed methods by all test cases in T, and d(b, T) indicates the minimal normalized branch distance for branch $ b \in B $
\end{problem}



1) Apply automated coverage testing for the software-in-the-loop stage
2) Multi-objective approach in the context of the input values of the considered environment, i.e. for a braking system, consider the following parameters as objectives to tune in order to maximize faults: precipitation, fogginess, visibility range)
