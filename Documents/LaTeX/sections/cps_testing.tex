Either one or two objectives for testing:
\begin{itemize}
    \item Fault revealing power
        [Gambi, A., Mueller, M., Fraser, G., 2019. Automatically testing
        self-driving cars with search-based procedural content generation, in:
        Proceedings of the 28th ACM SIGSOFT International Symposium on
        Software Testing and Analysis, pp. 318–328.]

    \item Fault revealing power and diversity[Riccio, V., Tonella, P., 2020a. Model-based exploration of the frontier
    of behaviours for deep learning system testing, in: Proceedings of the
    28th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering,
    pp. 876–888]
\end{itemize}

 Three approaches: random search, single-objective GA (AmbieGen), and multi-objective GA (NSGA-II).

For the first objective, a simplified  model of the system is used, since the full model can be expensive to run.
 [Menghi, C., Nejati, S., Briand, L., Parache, Y.I., 2020.
 Approximation-refinement testing of compute-intensive cyberphysical models: An approach based on system identification,
 in: 2020 IEEE/ACM 42nd International Conference on Software
 Engineering (ICSE), IEEE. pp. 372–384]

Approximations can be good enough.

Three test generation case studies:
\begin{itemize}
    \item Smart thermostat agent, with the goal of generating the temperature schedule and a combination of enviromental conditions violating the requirement.
    \item Autonomous robot that should navigate to a goal location in an indoor environment with obstacles, without bumping into them. The goal is to find an indoor environment that makes the robot violate the requirements.
    \item Autonomous vehicle with a lane-keeping assist system, LKAS, should follow a road lane of the given trajectory, without going out of its bounds. The goal here is to generate a virtual road that forces the car to go out of bounds.
\end{itemize}


In classical CPS testing, an exhaustive search of the state-space of the model is performed, by using an abstract model created after the system requirements to generate test cases for the SUT. If the outputs of the SUT model and abstract model are different, the fault in the SUT is revealed.
This approach becomes infeasible as the system's complexity grows.

Statistical Model Checking methods monitor some simulations of the system and then compute the probability along with confidence intervals that a specific requirement holds for the SUT. Here, requirements are specified using TCTL, timed computation tree logic, notation.

A number of tools were developed that instead of calculating the probability that a system satisfies the property with a certain confidence, compute the worst expected system behavior as a quantitative value, called robustness.


Objective $ F_1 $, the fault revealing power, is problem-specific and is defined as the difference between the expected and observed behavior of the agent.
The problem can be formulated as finding a test case forcing the agent to take such actions $ a_t $ that lead to violation of the established requirements and failure of the mission.
Therefore, each test case represents an environment for the agent, as well as the mission it needs to accomplish in it.


-------------------------------------------------------------------------\newline
For example, to test a self-driving vehicle we should
consider such parameters as the road type and size, the
location of other vehicles or pedestrians, the driving weather
conditions, etc. Evidently, one of the most important requirements would be the collision avoidance


A test case is split into at most $ m $ parts, each representing some aspect of the mission. Each part is $ E_i $.
Each element is then described with $ n $ parameters/attributes, denoted with $ A_i $.
As a result, each test case is represented as a $ nxm $ matrix where cell $ (i, j) $ contains the attribute value of $ A_i $ for part $ E_i $.
-------------------------------------------------------------------------\newline
As an example, let’s consider a car lane keeping assist
system (LKAS). It’s main goal is to keep the vehicle within
the road lane. One of the possible test cases to test this system
can be a road topology, that the vehicle needs to follow. To
design the test case, we suggest representing the road topology as a combination of road segments of different length
and curvature. Here, each road segment would correspond
to one environmental element and it’s parameters such as
length and curvature - the attributes of the environmental
element
-------------------------------------------------------------------------\newline

Finally, test cases can have restrictions $ R $, which limit the scenario length $ M $, or require particular combination of attributes.

To estimate the first objective's fitness function $ F_1 $, the difference between the expected and observed behaviors is computed, which varies on a case by case basis.

-------------------------------------------------------------------------\newline
The expected behaviour $ B(TC) $is typically defined in the system
requirements or formulated by the developers e.g., "the car
should not deviate from the lane center for more than 1
meter"
-------------------------------------------------------------------------\newline

To estimate the second fitness function $ F_2 $, the variability of the test case, the Jaccard distance between it and a reference test case is calculated.

Implemented with Pymoo