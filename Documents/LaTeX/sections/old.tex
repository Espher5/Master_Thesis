\newpage
\section{An overview on search problems}
As humans, everyday we perform search: from looking for our car keys in the house to searching for a new book to purchase, this action is engraved in our daily life.
In the same way, search is one of the most fundamental operations on which computer science has focused since its early days: performing efficient search is the core operation of many classes of algorithms, such as the ones responsible for route planning, computer vision, robotics, automated software testing, puzzle solving, and many others.


Any search problem is typically defined by: 
\begin{itemize}
    \item A search space: the set of elements in which we search for our solution. Examples include paths in a graph, the numbers to insert in a sorted list, or the web pages accesses by a web index.
    \item A condition that defines the characteristics of candidate solutions.
\end{itemize}

\textbf{formal problem definition with graphs, distance functions, ...}

A search algorithm will therefore examine the search space according to some criteria and attempt to find a suitable solution. Finding any candidate solution is just one of the objective of search problems however, often times we are interested in finding the best possible solution, the optimum; such problems are referred to as optimization problems.

The exploration of the search space can happen in many different ways. The most basic approach consists of exploring the elements one by one, till a solution/the optimum is found, in a brute-force manner. Applying this simple solution for problems whose search space is somewhat limited can be done without too many repercussions on execution time, however, given the exponential size of the search spaces of most practical problems, a brute-force approach is infeasible. 

For problems in which we have no choice but to employ brute-force search, there may be some room for improvement by using heuristics. Heuristics are estimates of the distance function to reach a goal state from the current node \cite{HeuristicSearch}.


Therefore, what it is preferred to obtain a solution that may not be the optimum, but rather it is "good enough" for our objective. This approach is called local search.

 
\textbf{Hill climbing, simulated annealing, GAs...}
Genetic Algorithms (GAs) are an example of an
evolutionary search approach for test case generation; starting from an initial, often randomly generated, population of 
test cases, the algorithm keeps evolving the individuals according to simulated natural evolution theory principles.
In this context, a typical fitness function of a GA would measure the distance between the execution trace of the generated test cases
and the coverage targets.


Either one or two objectives for testing:
\begin{itemize}
    \item Fault revealing power
        [Gambi, A., Mueller, M., Fraser, G., 2019. Automatically testing
        self-driving cars with search-based procedural content generation, in:
        Proceedings of the 28th ACM SIGSOFT International Symposium on
        Software Testing and Analysis, pp. 318–328.]

    \item Fault revealing power and diversity[Riccio, V., Tonella, P., 2020a. Model-based exploration of the frontier
    of behaviours for deep learning system testing, in: Proceedings of the
    28th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering,
    pp. 876–888]
\end{itemize}

 Three approaches: random search, single-objective GA (AmbieGen), and multi-objective GA (NSGA-II).

For the first objective, a simplified  model of the system is used, since the full model can be expensive to run.
 [Menghi, C., Nejati, S., Briand, L., Parache, Y.I., 2020.
 Approximation-refinement testing of compute-intensive cyberphysical models: An approach based on system identification,
 in: 2020 IEEE/ACM 42nd International Conference on Software
 Engineering (ICSE), IEEE. pp. 372–384]

Approximations can be good enough.

Three test generation case studies:
\begin{itemize}
    \item Smart thermostat agent, with the goal of generating the temperature schedule and a combination of enviromental conditions violating the requirement.
    \item Autonomous robot that should navigate to a goal location in an indoor environment with obstacles, without bumping into them. The goal is to find an indoor environment that makes the robot violate the requirements.
    \item Autonomous vehicle with a lane-keeping assist system, LKAS, should follow a road lane of the given trajectory, without going out of its bounds. The goal here is to generate a virtual road that forces the car to go out of bounds.
\end{itemize}


In classical CPS testing, an exhaustive search of the state-space of the model is performed, by using an abstract model created after the system requirements to generate test cases for the SUT. If the outputs of the SUT model and abstract model are different, the fault in the SUT is revealed.
This approach becomes infeasible as the system's complexity grows.

Statistical Model Checking methods monitor some simulations of the system and then compute the probability along with confidence intervals that a specific requirement holds for the SUT. Here, requirements are specified using TCTL, timed computation tree logic, notation.

A number of tools were developed that instead of calculating the probability that a system satisfies the property with a certain confidence, compute the worst expected system behavior as a quantitative value, called robustness.


Objective $ F_1 $, the fault revealing power, is problem-specific and is defined as the difference between the expected and observed behavior of the agent.
The problem can be formulated as finding a test case forcing the agent to take such actions $ a_t $ that lead to violation of the established requirements and failure of the mission.
Therefore, each test case represents an environment for the agent, as well as the mission it needs to accomplish in it.


-------------------------------------------------------------------------\newline
For example, to test a self-driving vehicle we should
consider such parameters as the road type and size, the
location of other vehicles or pedestrians, the driving weather
conditions, etc. Evidently, one of the most important requirements would be the collision avoidance


A test case is split into at most $ m $ parts, each representing some aspect of the mission. Each part is $ E_i $.
Each element is then described with $ n $ parameters/attributes, denoted with $ A_i $.
As a result, each test case is represented as a $ nxm $ matrix where cell $ (i, j) $ contains the attribute value of $ A_i $ for part $ E_i $.
-------------------------------------------------------------------------\newline
As an example, let’s consider a car lane keeping assist
system (LKAS). It’s main goal is to keep the vehicle within
the road lane. One of the possible test cases to test this system
can be a road topology, that the vehicle needs to follow. To
design the test case, we suggest representing the road topology as a combination of road segments of different length
and curvature. Here, each road segment would correspond
to one environmental element and it’s parameters such as
length and curvature - the attributes of the environmental
element
-------------------------------------------------------------------------\newline

Finally, test cases can have restrictions $ R $, which limit the scenario length $ M $, or require particular combination of attributes.

To estimate the first objective's fitness function $ F_1 $, the difference between the expected and observed behaviors is computed, which varies on a case by case basis.

-------------------------------------------------------------------------\newline
The expected behaviour $ B(TC) $is typically defined in the system
requirements or formulated by the developers e.g., "the car
should not deviate from the lane center for more than 1
meter"
-------------------------------------------------------------------------\newline

To estimate the second fitness function $ F_2 $, the variability of the test case, the Jaccard distance between it and a reference test case is calculated.

Implemented with Pymoo
BeamNG.drive for vehicle simulation

Tools for simulations:
Smart Thermostat: 
Smart robot: Player/Stage with Pioneer 3-AT
LKAS: BeamNG.tech + model from scratch



\textbf{Riccio, Tonella - Model-based Exploration of the Frontier of Behaviours for Deep Learning System Testing}
Development of DeepJanus, a search-based tool that generates frontier inputs for DL systems.
Experiments performed on a lane keeping component of a self-driving car 

Frontier: inputs of the DL system that cause it to misbehave

They consider a self-driving car trained and tested with BeamNG.drive. The unput of the steering angle predictor is an image captured the onboard sensor camera in the simulated environment

Using DEAP evolutionary computation framework in Python